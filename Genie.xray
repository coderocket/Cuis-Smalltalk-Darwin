tokens

".." Gene Parameters Functions Rules "(" ")" ":" "," group by penalty "+" "-"  max "(" ")" ";" bonus penalty


patterns

#[[:print:]]+:isNewLine: 								{ nextTerminal }
[[:space:]]+								{ nextTerminal }
[[:alpha:]]+								name
"[0-9]+\.[0-9]+(e-[0-9]+)?" 								float
[0-9]+								number
\* 								multiply
"<=|>=|<|>|!="								compop
"="								equal

rules

%topic main

Start 'x' : Params 'p' Schema 'g' Fitness 'r'

	{ attrs @ x = attrs @ g }

	{ params @ x = code @ p }

	{ tables @ g = Set new }

	{ schema @ x = code @ g }

	{ mutate @ x = mutate @ g }

	{ fitness @ x = code @ r }
	;

Start 'x' : Params 'p' Schema 'g' Fun 'f' Fitness 'r'

	{ attrs @ x = attrs @ g }

	{ params @ x = code @ p }

	{ tables @ g = (tables @ f) asSet }

	{ schema @ x = code @ g }

	{ functions @ x = code @ f }

	{ mutate @ x = mutate @ g }

	{ attrs @ r = attrs @ g }

	{ fitness @ x = code @ r }
	;


%topic structure

Schema 'x' : Gene Component + 'c' 

	{ code @ x = GenieCompiler instance compileSchema: attr @ c } 

	{ mutate @ x = code @ c fold:[:acc :each | acc , String lfString, each ] }

	{ attrs @ x = (raw @ c) }

	;

Component 'x' : Name 'n' ":" Value 'v'
	
	{ code @ x = 'a_gene[{1}] = {2};'	 format: { value @ n  . code @ v } } 

	{ attr @ x =  value @ n }

	{ val @ x = code @ v }

	{ raw @ x =  raw @ n }

	;

Name 'x' : name 'n'

	{ value @ x = GenieCompiler instance compileName: n value asString }

	{ raw @ x = n value asString }

	;

Value 'x' : 

	number 'n'

	{ code @ x = n value asString }

	|

	float 'n'

	{ code @ x = n value asString }

	| Range 'r'

	{ code @ x = 'interval_t({1} , {2}).at_random()' format: { b@r . e@r } }

	| Function 'f'

	{ code @ x = '{1}({2})' format: { (n@f)  . e@f } };

Range 'x' : number 'b' ".." number  'e'	

	{ b@x = b value  }

	{ e@x = e value  }

	{ code @ x = '(interval_t({1},{2}))' format: { b value . e value } }

	;

Function 'x' : name 'n' "(" Name 'e' ")"

	{ n @ x = GenieCompiler instance compileSchemaFunctionName: n value asString inTables: tables @ x }

	{ e @ x = 'a_gene[{1}]' format: { value @ e  } }

	;

%topic fitness

Fitness 'x' : Rules Rule + 'r'

	{ code @ x = (code @ r) fold:[:acc :each | acc , String lfString , each ] }

	;

Rule 'x' : bonus Aggr 'a' 

	{ kind @ a = 1 }

	{ code @ x = code @ a }

	| penalty Aggr 'a'

	{ kind @ a = -1 }

	{ code @ x = code @ a }
;

Aggr 'x' : group by "(" Names 'ns' ")" Expr 'e'  ";"
	 
	{ code @ x = GenieCompiler instance compileRuleGroupByKeys: names @ ns expr: value @ e kind: kind @ x }
 
	| Expr 'e' ";"

	{ code @ x = GenieCompiler instance compileRuleExpr: value @ e kind: kind @ x }

	;

Expr 'x' : Expr 'left' max Term 'right'  

	{ value @ x = '(max(({1}),({2})))' format:{ value @ left . value @ right }  }

	| Compare 'c'

	{ value @ x = value @ c }

	;

Compare 'x' : Compare 'left' compop 'op' Term 'right' 

	{ value @ x = '(({1}) {2} ({3}))' format: { value @ left . (op value asString) . value @ right } }

	| Compare 'left' equal Term 'right' 

	{ value @ x = '(({1}) == ({2}))' format: { value @ left . value @ right } }

	| Term 't'

	{ value @ x = value @ t }

	;

Term 'x' : Term 'left' "+" Factor 'right'

	{ value @ x = '(({1}) + ({2}))' format:{ value @ left . value @ right } }

	| Term 'left' "-" Factor 'right'
	
	{ value @ x = '(({1}) - ({2}))' format:{ value @ left . value @ right } }

	| Factor 'y'  

	{ value @ x = value @ y }
	;

Factor 'x' : Primitive 'p'

	{ value @ x = value @ p }

	| Factor 'left' multiply Primitive 'right'

	{ value @ x = '(({1}) * ({2}))' format:  { value @ left . value @ right }  }

	;

Primitive 'x' : number 'n' 

	 { value@x = n value asString }

	| name 'n' "(" E 'e' ")" 

	{ value @ x = GenieCompiler instance compileRulePrimitiveCallName: n value expr: value @ e }

	| name 'n' 

	{ value @ x = '(*each)[{1}]' format: { GenieCompiler instance compileRuleName: n value asString isMemberIn: attrs @ x } } 

	| "(" Compare 'c' ")" 

	{ value @ x = value @ c }

	;

E 'x' : E 'left' ".." T 'right'

	{ value @ x = 'interval_t({1}, {2})' format: { value @ left . value @ right } }

	| T 't'

	{ value @ x = value @ t }

	;

T 'x' : T 'left' "+" F 'right'

	{ value @ x = '({1}) + ({2})' format: { value @ left . value @ right } }

	| F 'f'

	{ value @ x = value @ f }

	;

F 'x' : Name 'n'

	{ value @ x = GenieCompiler instance compileRuleVariable: raw @ n in: attrs @ x }

	| number 'n'
	
	{ value @ x = n value }

	;

Names 'x' : Name 'n' 

	{ names @ x = { value @ n  } }

	| Names 'xs' "," Name 'n'  

	{ names @ x = (names @ xs) , { value @ n } }

	;

%topic functions

Fun 'x' : Functions Table + 't' 

	{ code @ x = code @ t fold:[:acc :each | acc, String lfString, each] }

	{ tables @ x = (table @ t) }

	;

Table 'x' : name 'n' Tuple + 't' 

	{ code @ x =  GenieCompiler instance compileTable: v@t name: n value asString }
	
	{ table @ x = { n value asString } }
	;

Tuple 'x' : Range 'r' Seq 's'
	
	{ v @ x = GenieCompiler instance compileTupleRangeBegin: b@r end:e@r seq: v@s }

	;

Tuple 'x' : Seq 'left' Seq 'right'
	 
	{ v @ x = GenieCompiler instance compileTuple: v@left seq: v@right }

;

Tuple 'x' : Seq 'seq' Range 'r'

	{ v @ x = GenieCompiler instance compileTuple: v@seq range: code@r }

	;

Seq 'x' : 

	number 'n'
	
	{ v @ x = { n value asString } }

	| Seq 'seq' "," number 'n'
	
	{ v @ x = (v @ seq) , { n value asString } }

	;


%topic parameters

Params 'x' : Parameters Component + 'c' 

	{ code @ x = GenieCompiler instance compileParameters: attr @ c values: val @ c }

	;