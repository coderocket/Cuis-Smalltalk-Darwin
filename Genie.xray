tokens

".." Schema Parameters Functions Rules "(" ")" ":" "," group by penalty "+" "-"  max "(" ")" ";" table bonus penalty for in


patterns

#[[:print:]]+:isNewLine: 								{ nextTerminal }
[[:space:]]+								{ nextTerminal }
[[:alpha:]_]+								name
"[0-9]+\.[0-9]+(e-[0-9]+)?" 								float
[0-9]+								number
\* 								multiply
"<=|>=|<|>|!="								compop
"="								equal
"!in"								notin

rules

%topic main

Start 'x' : Params 'p' Structure 'g' Fun 'f' Fitness 'r'

	{ attrs @ x = attrs @ g }

	{ params @ x = code @ p }

	{ fnames @ g = (fnames @ f) asSet }

	{ schema @ x = code @ g }

	{ functions @ x = code @ f }

	{ tables @ x = tables @ f }

	{ mutate @ x = mutate @ g }

	{ attrs @ r = (attrs @ g) }

	{ tnames @ r = tnames @ f }

	{ fitness @ x = code @ r }

	;


%topic structure

Structure 'x' : Schema Component + 'c' 

	{ code @ x = GenieCompiler instance compileSchema: attr @ c } 

	{ mutate @ x = GenieCompiler instance compileAttributeLayout: code @ c }

	{ attrs @ x = (raw @ c) }

	;

Component 'x' : Name 'n' ":" Value 'v'
	
	{ code @ x = GenieCompiler instance compileMutateName: value @ n  value: code @ v } 

	{ attr @ x =  value @ n }

	{ val @ x = code @ v }

	{ raw @ x =  raw @ n }

	{ type @ x = type @ v }
	
	;

Name 'x' : name 'n'

	{ value @ x = GenieCompiler instance compileName: n value asString }

	{ raw @ x = n value asString }

	;

Value 'x' : 

	number 'n'

	{ code @ x = n value asString }

	{ type @ x = 'int' }

	|

	float 'n'

	{ code @ x = n value asString }

	{ type @ x = 'double' }

	| Range 'r'

	{ code @ x = 'interval_t({1} , {2})' format: { b@r . e@r } }

	{ type @ x = 'interval_t' }

	;

Range 'x' : number 'b' ".." number  'e'	

	{ b@x = b value  }

	{ e@x = e value  }

	{ code @ x = '(interval_t({1},{2}))' format: { b value . e value } }

	;

Function 'x' : name 'n' "(" Name 'e' ")"

	{ n @ x = GenieCompiler instance compileSchemaFunctionName: n value asString inTables: fnames @ x }

	{ e @ x = 'a_gene[{1}]' format: { value @ e  } }

	;

%topic fitness

Fitness 'x' : Rules Rule + 'r'

	{ code @ x = (code @ r) fold:[:acc :each | acc , String lfString , String lfString, each ] }

	;

Rule 'x' : bonus Group 'a' 

	{ kind @ a = 1 }

	{ code @ x = code @ a }

	| penalty Group 'a'

	{ kind @ a = -1 }

	{ code @ x = code @ a }
;
 
Group 'x' : group by "(" Names 'ns' ")" Expr 'e'  ";"
	 
	{ code @ x = GenieCompiler instance compileRuleGroupByKeys: names @ ns expr: value @ e kind: kind @ x }

	{ group @ e = 1 }

	| for name 'index' in name 'tab' "(" name 'key1' "," name 'key2' ")" E 'e' ";"
 
	{ code @ x = GenieCompiler instance compileTableExpr: tab index: index key: key1 key: key2 expr: value @ e kind: kind @ x }
	{ locals @ e = { index value asString } asSet }

	| Expr 'e' ";"

	{ code @ x = GenieCompiler instance compileRuleExpr: value @ e kind: kind @ x }

	{ group @ e = 0 }

	;

Expr 'x' : Expr 'left' max Term 'right'  

	{ value @ x = '(max(({1}),({2})))' format:{ value @ left . value @ right }  }

	| Compare 'c'

	{ value @ x = value @ c }

	;

Compare 'x' : Compare 'left' compop 'op' Term 'right' 

	{ value @ x = '(({1}) {2} ({3}))' format: { value @ left . (op value asString) . value @ right } }

	| Compare 'left' equal Term 'right' 

	{ value @ x = '(({1}) == ({2}))' format: { value @ left . value @ right } }

	| Compare 'left' notin Term 'right' 

	{ value @ x = '(int)(!({2}).contains({1}))' format: { value @ left . value @ right } }

	| Term 't'

	{ value @ x = value @ t }

	;

Term 'x' : Term 'left' "+" Factor 'right'

	{ value @ x = '(({1}) + ({2}))' format:{ value @ left . value @ right } }

	| Term 'left' "-" Factor 'right'
	
	{ value @ x = '(({1}) - ({2}))' format:{ value @ left . value @ right } }

	| Factor 'y'  

	{ value @ x = value @ y }
	;

Factor 'x' : Primitive 'p'

	{ value @ x = value @ p }

	| Factor 'left' multiply Primitive 'right'

	{ value @ x = '(({1}) * ({2}))' format:  { value @ left . value @ right }  }

	;

Primitive 'x' : number 'n' 

	 { value@x = n value asString }

	| name 'n' "(" E 'e' ")" 

	{ locals @ e = Set new }

	{ value @ x = GenieCompiler instance compileRulePrimitiveCallName: n value expr: value @ e group: group@x }

	| name 'n' 

	{ value @ x = '(*each)[{1}]' format: { GenieCompiler instance compileRuleName: n value asString isMemberIn: attrs @ x } } 

	| "(" Compare 'c' ")" 

	{ value @ x = value @ c }

	;

E 'x' : E 'left' ".." T 'right'

	{ value @ x = 'interval_t({1}, {2})' format: { value @ left . value @ right } }

	| T 't'

	{ value @ x = value @ t }

	;

T 'x' : T 'left' "+" F 'right'

	{ value @ x = '({1}) + ({2})' format: { value @ left . value @ right } }

	| F 'f'

	{ value @ x = value @ f }

	;

F 'x' : Name 'n'

	{ value @ x = GenieCompiler instance compileRuleVariable: raw @ n attrs: (attrs @ x) locals: (locals @ x)  }

	| Name 'n' "(" Es 'e' ")" 

	{ value @ x = GenieCompiler instance compileRuleInnerCall: raw @ n args: value @ e}

	| number 'n'
	
	{ value @ x = n value }

	;

Es 'x' : E 'e' 
	
	| Es 'list' "," E 'e'

	;

Names 'x' : Name 'n' 

	{ names @ x = { value @ n  } }

	| Names 'xs' "," Name 'n'  

	{ names @ x = (names @ xs) , { value @ n } }

	;

%topic functions

Fun 'x' : Functions Table + 't' 

	{ code @ x = code @ t reduce:[:u :v | u, String lfString, v] }

	{ fnames @ x = fname @ t }

	{ tables @ x = table @ t reduce:[:u :v | u, String lfString, v] }

	{ tnames @ x = tname @ t }
	;

Table 'x' : name 'n' Tuple + 't' 

	{ code @ x =  GenieCompiler instance compileFunction: v@t name: n value asString type: type @ t }
	
	{ fname @ x = { n value asString } }

	;

Tuple 'x' : Range 'r' Seq 's'
	
	{ v @ x = GenieCompiler instance compileTupleRangeBegin: b@r end:e@r seq: v@s }

	{ type @ x = type @ s }

	;

Tuple 'x' : Seq 'left' Seq 'right'
	 
	{ v @ x = GenieCompiler instance compileTuple: v@left seq: v@right }

	{ type @ x = type @ right }

;

Tuple 'x' : Seq 'seq' Range 'r'

	{ v @ x = GenieCompiler instance compileTuple: v@seq range: code@r }

	{ type @ x = GenieCompiler rangeType }

	;

Table 'x' : table name 'n' Triple + 't'  

	{ table @ x =  GenieCompiler instance compileTripleTable: v@t name: n value asString }
	
	{ tname @ x = { n value asString } }
	
	;

Triple 'x' : number 'a1' number 'a2' Range 'y'

	{ v @ x = GenieCompiler instance compileTriple: a1 value and: a2 value range: code@y }

	 ;

Seq 'x' : 

	number 'n'
	
	{ v @ x = { n value asString } }

	{ type @ x = GenieCompiler numberType }

	| Seq 'seq' "," number 'n'
	
	{ v @ x = (v @ seq) , { n value asString } }

	{ type @ x = GenieCompiler seqType }

	;


%topic parameters

Params 'x' : Parameters Component + 'c' 

	{ code @ x = GenieCompiler instance compileParameters: attr @ c values: val @ c types: type @ c }

	;